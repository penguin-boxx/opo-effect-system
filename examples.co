data Unit = Unit

data Option<a> = None | Some(a)

data Result<e, a> = Error(e) | Ok(a)


data File = File

fun withFile<r>(f: (File'local) -> r): r =
    f(File())


data List<a> = Nil | Cons(a, List<a>)

fun cons[la]<a <: Any'la>(x: a): (List<a>)'la -> List<a> =
    fun(xs: List<a>) Cons<a>(x, xs)

let list = cons[local]<File'local>(File())



// (f: (b) -> c, g: (a) -> b) -> (x: a)'f+g -> c
fun compose
    [lf, lg]
    <a <: Any'local, b <: Any'local, c <: Any'local>
    (f: (b)'lf -> c, g: (a)'lg -> b): (a)'lf+lg -> c =
    fun(x : a) f(g(x))



let id = fun<a <: Any'local>(x: a) x

fun downcast<t>(x: t): t = x


effect Reader<e> {
    op ask(): e
}

fun withReader[lr]<e, r <: Any'lr>(
    f: context(Reader<e>) ()'local -> r
): (e)'lr -> r =
    handle r: Reader<e> {
        op ask() fun(e: e) resume(e)(e)
    }
    let x: r = f() in
    fun(e: e) x

let readerExample =
    handle r: Reader<Int> {
        op ask() resume(42)
    }
    perform r.ask()

effect State<s> {
    op get(): s
    op put(s): Unit
}

fun withState
    [lr]<s <: Any'free, r <: Any'lr>
    (f: context(State<s>) ()'local -> r): (s)'lr -> r =
    handle st: State<s> {
        op get() fun(s: s) resume(s)(s)
        op put(s) fun(old: s) resume(Unit())(s)
    }
    let x: r = f() in
    fun(s: s) x

// error
// fun testWithState(): Unit =
//     withState[free]<Option<Reader<Unit>'local>, Unit'free>(
//         context(st: State<Option<Reader<Unit>'local>>'local) fun()
//             let x: Unit = withReader<Unit, Unit>(context(r: Reader<Unit>'local) fun()
//                 perform st.put(Some<Reader<Unit>'local>(r))
//             )(Unit()) in
//             match perform st.get() {
//                 case None() -> Unit()
//                 case Some(r) -> perform r.ask()
//             }
//     )(None<Reader<Unit>'local>())


effect Exception<e> {
    op throw<a>(e): a
}

fun withException<e <: Any'free, r>(f: context(Exception<e>) () -> r): Result<e, r> =
    handle h: Exception<e> {
        op throw<a>(e) Error<e, r>(e)
    }
    Ok<e, r>(f(h;))

let exampleException =
    withException<Int, File>(context(h: Exception<Int>) fun()
        perform h.throw<File>(42)
    )


data LazyList<a>
    = LNil
    | LCons[lh, lt, ll](()'lh -> a, ()'lt -> LazyList<a>'ll)

fun lazyMap
    [lf, la, lb]<a <: Any'la, b <: Any'lb>
    (xs: LazyList<a>, f: (a)'lf -> b): LazyList<b>'lf+la =
    match xs {
        case LNil() -> LNil<b>()
        case LCons(h, t) -> LCons[lf+la, lf+la, lf+la]<b>(
            fun() f(h()),
            fun() lazyMap[lf, la, lb]<a, b>(t(), f)
        )
    }


data Pair<a, b> = Pair(a, b)

fun mapFirst
    [la, lb, lc]<a <: Any'la, b <: Any'lb, c <: Any'lc>
    (p: Pair<a, b>, f: (a)'local -> c): Pair<c, b> =
    match p {
        case Pair(x, y) -> Pair<c, b>(f(x), y)
    }


data EndoI = EndoI[l]((Int'l) -> Int'l)

fun foldEndo[l0](_: Int'l0, endo: EndoI'l0): Int'l0 =
    match endo { case EndoI(f) -> f(42) }

data Endo<a> = Endo((a) -> a)
data Trash = Trash[l](Endo<Int'l>)

// error
//fun crashEndo(x: Int'local): Unit =
//    let trash: Trash'local = Trash[free](Endo<Int>(fun(x: Int) x)) in
//    let endo: Endo<Int'*>'local = match trash { case Trash(endo) -> endo } in
//    let _: Int'local = match endo { case Endo(f) -> f(x) } in
//    Unit()

//data Box = Box[l](Option<Int'l>)
//let crashBox =
//    let x: Int'local = 42 in
//    let b: Box'local = Box[local](Some<Int'local>(x)) in
//    let o: Option<Int'*> = match b { case Box(o) -> o } in
//    match o {
//        case None() -> 42
//        case Some(x) -> x
//    }


// context(x: Int'free, y: Int'local)
// fun clash(): Unit = Unit()


effect Id {
    op id<a>(a): a
}

fun withId<r>(f: context(Id) () -> r): r =
    handle h: Id {
        op id(x) resume(x)
    }
    f()

effect Optionality {
    op mkSome<a>(a): Option<a>
}

let exampleOptionality =
    handle o: Optionality {
        op mkSome<b>(x) resume(Some<b>(x))
    }
    perform o.mkSome<Int>(42)
